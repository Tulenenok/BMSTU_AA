\chapter{Исследовательская часть}

В данном разделе приводятся результаты замеров алгоритмов по пиковой памяти и процессорному времени.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item Операционная система: macOS Monterey 12.5.1 
	\item Память: 16 Гб.
	\item Процессор: 2,3 ГГц 4‑ядерный процессор Intel Core i5.
\end{itemize}

Во время тестирования устройство было подключено к сети электропитания, нагружено приложениями окружения и самой  системой тестирования.

\section{Время выполнения алгоритмов}

Алгоритмы тестировались при помощи функции time() из библиотеки time языка Python. Данная функция возвращает количество секунд, прошедших с начала эпохи, типа float.

Контрольная точка возвращаемого значения не определна, поэтому допустима только разница между результатами последовательных вызовов.

Замеры времени для каждой длины слов проводились 1000 раз. В качестве результата взято среднее время работы алгоритма на данной длине слова. При каждом запуске алгоритма, на вход подавались случайно сгенерированные строки. Тестовые пакеты создавались до начала замера времени.

На рисунке \ref{img:dl} приведена схема нерекурсивного алгоритма нахождения расстояния Дамерау-Левенштейна.

Результаты замеров приведены на рисунке \ref{img:time} (в микросекундах).

\img{37mm}{time}{Результаты замеров времени (в микросекундах)}

 
\section{Использование памяти}

Алгоритмы тестировались при помощи функции get\_traced\_memory() из библиотеки tracemalloc языка Python, которая возвращает пиковый количество памяти, использованное процессором, на определенном этапе выполнения программы.

При каждом запуске алгоритма, на вход подавались случайно сгенерированные строки. Тестовые пакеты создавались до начала замера памяти.

Результаты замеров приведены на рисунке \ref{img:memory} (в байтах).

\img{34mm}{memory}{Результаты замеров памяти (в байтах)}

\section*{Вывод}

В результате замеров можно прийти к выводу, что матричная реализация алгоритмов нахождения расстояний заметно выигрывает по времени при росте строк, но проигрывает по количеству затрачиваемой памяти.
