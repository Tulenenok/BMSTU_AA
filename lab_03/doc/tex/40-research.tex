\chapter{Исследовательская часть}

В данном разделе приводятся результаты замеров алгоритмов по процессорному времени.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item Операционная система: macOS Monterey 12.5.1 
	\item Память: 16 Гб.
	\item Процессор: 2,3 ГГц 4‑ядерный процессор Intel Core i5.
\end{itemize}

Во время тестирования устройство было подключено к сети электропитания, нагружено приложениями окружения и самой  системой тестирования.

\section{Время выполнения алгоритмов}

Алгоритмы тестировались при помощи функции time() из библиотеки time языка Python. Данная функция возвращает количество секунд, прошедших с начала эпохи, типа float.

Контрольная точка возвращаемого значения не определна, поэтому допустима только разница между результатами последовательных вызовов.

Замеры времени для каждой длины массива проводились 1000 раз. В качестве результата взято среднее время работы алгоритма на данной длине массива. При каждом запуске алгоритма, на вход подавались случайно сгенерированные массивы. Тестовые пакеты создавались до начала замера времени.

Результаты замеров приведены на рисунках \ref{img:time1}, \ref{img:time2}, \ref{img:time3} (в микросекундах).

\img{63mm}{time1}{Результаты замеров времени для неотсортированного массива (в микросекундах)}
\img{63mm}{time2}{Результаты замеров времени для отсортированного массива (в микросекундах)}
\img{63mm}{time3}{Результаты замеров времени для отсортированного в обратном порядке массива (в микросекундах)}

\section*{Вывод}

Алгоритм гномьей сортировки работает быстрее алгоритмов плавной сортировки и сортировки бинарным деревом независимо от того, как расположены объекты в сортируемом массиве. Напротив, сортировка бинарным деревом проигрывает двум другим алгоритмам по времени, так как использует рекурсию. Также можно заметить, что алгоритму плавной сортировки не важно, как расположены объекты в массиве, он всегда будет давать примерно одинаковые временные результаты.
