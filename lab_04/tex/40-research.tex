\chapter{Исследовательская часть}

В данном разделе были приведены примеры работы программ, постановка эксперимента и сравнительный анализ алгоритмов на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item Операционная система macOS Monterey 12.5.1 
	\item Память 16 Гб.
	\item Процессор 2,3 ГГц 4‑ядерный процессор Intel Core i5.
\end{itemize}

Во время тестирования устройство было подключено к сети электропитания, нагружено приложениями окружения и самой  системой тестирования.

\section{Время выполнения алгоритмов}

Для замера процессорного времени использовалась функция 
\\ \textit{std::chrono::system\_clock::now(...)} из библиотеки $chrono$ \cite{cpp-lang-chrono} на C++. Функция возвращает процессорное время типа float в секундах.

Контрольная точка возвращаемого значения не определена, поэтому допустима только разница между результатами последовательных вызовов.

Замеры времени для каждой длины входного массива полигонов проводились 1000 раз. В качестве результата взято среднее время работы алгоритма на данной длине. При каждом запуске алгоритма, на вход подавались случайно сгенерированные массивы полигонов. 

\subsection{Время выполнения однопоточной реализации}

Результаты замеров приведены в таблице \ref{tbl:best}.

\begin{table}[h]
	\begin{center}
		\captionsetup{justification=raggedright,singlelinecheck=off}
		\caption{\label{tbl:best}Результаты замеров времени однопоточной и последовательной реализаций в микросекундах (N - количество полигонов)}
		\begin{tabular}{|c|c|c|c|}
			\hline
			N&Однопоточное выполнение&Последовательное выполнение\\
			\hline
			10 & 30 & 28 \\
			\hline
			20 & 35 & 31 \\
			\hline
			30 & 40 & 36 \\
			\hline
			50 & 43 & 39 \\
			\hline
			100 & 57 & 49 \\
			\hline
			200 & 75 & 69 \\
			\hline
			
		\end{tabular}
	\end{center}
\end{table}

\subsection{Время выполнения многопоточной реализации}

Результаты замеров приведены в таблице \ref{tbl:wor}.

\captionsetup{justification=raggedright,singlelinecheck=false}
\begin{table}[h]
	\begin{center}
		\caption{\label{tbl:wor} Результаты замеров времени выполнения программы, реализующей многопоточный алгоритм удаления невидимых граней, использующий Z-буфер, для разного количества потоков в микросекундах.}
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline				
			\multirow{3}{*}{\makecell{Количество\\ треугольников\\ }} & 	\multicolumn{6}{c|}{Количество потоков} \\ [3ex]
			\cline{2-7}		
			&1&	4&	6&	12&	24& 48\\
			\hline		
			10&	    30&	33&	25&	23&	21&	27\\
			\hline		
			100&	57&	75&	 76&	73&	53&	0,78\\
			\hline		
			1000&	245&	143&	118&	103&	99&	128\\
			\hline		
			10000&	2098&	845&	688&	603&	561& 642\\
			\hline		
			100000&	19935&	5606&	5231&	4689&	4487& 4992\\
			\hline			
			
		\end{tabular}
	\end{center}
\end{table}

\newpage


При 6 потоках достигается пик, при котором все логические ядра
процессора одновременно выполняют параллельные ветки алгоритма. Далее
при увеличении числа потоков производительность падает. Это объясняет-
ся тем, что создается очередь потоков, которая замедляет работу програм-
мы.

\section*{Вывод}

В данном разделе было произведено сравнение времени выполнения
реализации алгоритма удаления невидимых ребер, при последовательной реализации и многопоточной. Результат показал, что выгоднее всего по времени использовать столько потоков, сколько у процессора логических ядер.


